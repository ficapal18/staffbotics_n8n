{
  "name": "Staffbotics Patient Grouping (MVP)",
  "nodes": [
    {
      "id": "1",
      "name": "Receive Batch (Webhook)",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        260,
        300
      ],
      "parameters": {
        "httpMethod": "POST",
        "path": "staffbotics-batch",
        "responseMode": "lastNode",
        "options": {}
      }
    },
    {
      "id": "2",
      "name": "Build RawItems",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        620,
        300
      ],
      "parameters": {
        "functionCode": "const { buildRawItemsFromWebhookBody } = require('staffbotics-helpers');\n\n// Webhook payload is usually in items[0].json.body, but handle both cases.\nconst payload = items[0].json.body ?? items[0].json;\n\nconst out = buildRawItemsFromWebhookBody(payload);\n\nreturn [{ json: out }];"
      }
    },
    {
      "id": "3",
      "name": "Heuristic Analysis",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        980,
        300
      ],
      "parameters": {
        "functionCode": "const { buildHeuristicAnalysis } = require('staffbotics-helpers');\n\nconst originalBody = items[0].json.originalBody ?? {};\nconst { analysisText } = buildHeuristicAnalysis(originalBody);\n\nreturn [{\n  json: {\n    ...items[0].json,\n    analysisText\n  }\n}];"
      }
    },
    {
      "id": "4",
      "name": "Structure Advisor (LLM)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        1360,
        300
      ],
      "parameters": {
        "url": "https://api.openai.com/v1/chat/completions",
        "method": "POST",
        "authentication": "none",
        "jsonParameters": true,
        "sendHeaders": true,
        "headerParametersJson": "{\n  \"Authorization\": \"Bearer {{$env.OPENAI_API_KEY}}\",\n  \"Content-Type\": \"application/json\"\n}",
        "bodyParametersJson": "{\n  \"model\": \"gpt-5.2-mini\",\n  \"temperature\": 0,\n  \"messages\": [\n    {\n      \"role\": \"system\",\n      \"content\": \"You output ONLY valid JSON (no markdown, no prose).\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"You are configuring a deterministic bulk-to-patient grouping step.\\n\\nReturn ONLY a JSON object with this schema:\\n{\\n  \\\"unit_strategy\\\": \\\"excel_row\\\"|\\\"subfolder\\\"|\\\"id_in_filename\\\"|\\\"fallback\\\",\\n  \\\"excel\\\": { \\\"id_column\\\": string|null },\\n  \\\"folder\\\": { \\\"id_patterns\\\": (string|{\\\"pattern\\\":string,\\\"group\\\":number})[] },\\n  \\\"quarantine\\\": { \\\"quarantine_threshold\\\": number }\\n}\\n\\nGuidance:\\n- If any Excel is present, prefer unit_strategy=excel_row, and set excel.id_column if an ID-like column is clear.\\n- If folders strongly look like per-patient folders, choose subfolder.\\n- If filenames contain consistent patient IDs, choose id_in_filename and propose 1-3 regex patterns. Prefer capture groups for the ID: {pattern: '...', group: 1}.\\n- Otherwise fallback.\\n- Set quarantine.quarantine_threshold to a sensible default (e.g., 0.55). Use higher (0.65) if data is noisy and you want fewer auto-processed candidates.\\n\\nHeuristic analysis:\\n{{$node[\\\"Heuristic Analysis\\\"].json.analysisText}}\"\n    }\n  ]\n}",
        "options": {}
      }
    },
    {
      "id": "5",
      "name": "Parse LLM Config",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1720,
        300
      ],
      "parameters": {
        "functionCode": "function safeParseJson(text) {\n  if (!text || typeof text !== 'string') return null;\n  try { return JSON.parse(text); } catch (e) {}\n  const m = text.match(/\\{[\\s\\S]*\\}/);\n  if (m) {\n    try { return JSON.parse(m[0]); } catch (e) {}\n  }\n  return null;\n}\n\n// This node receives the HTTP response as items[0].json\nconst llmResp = items[0].json;\nconst content = llmResp?.choices?.[0]?.message?.content ?? '';\n\nconst groupingConfig = safeParseJson(content) || { unit_strategy: 'excel_row', excel: { id_column: null }, folder: { id_patterns: [] } };\n\n// Pull rawItems + analysisText from the previous deterministic nodes\nconst rawItems = $node['Heuristic Analysis'].json.rawItems ?? [];\nconst analysisText = $node['Heuristic Analysis'].json.analysisText ?? '';\nconst originalBody = $node['Heuristic Analysis'].json.originalBody ?? {};\n\nreturn [{\n  json: {\n    rawItems,\n    analysisText,\n    originalBody,\n    groupingConfig,\n    llm_raw: content\n  }\n}];"
      }
    },
    {
      "id": "6",
      "name": "Auto Grouping",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        2080,
        300
      ],
      "parameters": {
        "functionCode": "const { autoGroup } = require('staffbotics-helpers');\n\nconst rawItems = items[0].json.rawItems ?? [];\nconst groupingConfig = items[0].json.groupingConfig ?? { unit_strategy: 'excel_row' };\nconst analysisText = items[0].json.analysisText ?? '';\n\nconst out = autoGroup(rawItems, groupingConfig, analysisText);\n\nreturn [{ json: out }];"
      }
    },
    {
      "id": "7",
      "name": "Summarize Proposal",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        2440,
        300
      ],
      "parameters": {
        "functionCode": "const { summarizeProposal } = require('staffbotics-helpers');\n\nconst patientCandidates = items[0].json.patientCandidates ?? [];\nconst groupingConfig = items[0].json.groupingConfig ?? {};\nconst analysisText = items[0].json.analysisText ?? '';\n\nconst { summary } = summarizeProposal(patientCandidates, groupingConfig, analysisText);\n\nreturn [{\n  json: {\n    ...items[0].json,\n    summary\n  }\n}];"
      }
    },
    {
      "id": "8",
      "name": "Apply Reorg (Webhook)",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        260,
        760
      ],
      "parameters": {
        "httpMethod": "POST",
        "path": "staffbotics-reorg",
        "responseMode": "lastNode",
        "options": {}
      }
    },
    {
      "id": "9",
      "name": "NL → Operations (LLM)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        620,
        760
      ],
      "parameters": {
        "url": "https://api.openai.com/v1/chat/completions",
        "method": "POST",
        "authentication": "none",
        "jsonParameters": true,
        "sendHeaders": true,
        "headerParametersJson": "{\n  \"Authorization\": \"Bearer {{$env.OPENAI_API_KEY}}\",\n  \"Content-Type\": \"application/json\"\n}",
        "bodyParametersJson": "{\n  \"model\": \"gpt-5.2-mini\",\n  \"temperature\": 0,\n  \"messages\": [\n    {\n      \"role\": \"system\",\n      \"content\": \"You output ONLY valid JSON array (no markdown, no prose).\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"Convert the instruction into an operations JSON array with schema: [{op:'merge'|'reassign'|'change_strategy', params:{...}}].\\n\\nInstruction:\\n{{$node[\\\"Apply Reorg (Webhook)\\\"].json.body.instruction}}\\n\\nValid candidate_ids:\\n{{JSON.stringify(($node[\\\"Apply Reorg (Webhook)\\\"].json.body.patientCandidates||[]).map(c=>c.candidate_id))}}\\n\\nValid raw_item ids:\\n{{JSON.stringify(($node[\\\"Apply Reorg (Webhook)\\\"].json.body.patientCandidates||[]).flatMap(c=>(c.raw_items||[]).map(r=>r.id)))}}\\n\\nRules:\\n- Use only valid IDs from the lists.\\n- merge params: {from:[candidate_id...], into:candidate_id}\\n- reassign params: {raw_item_id:rawItemId, new_candidate:candidate_id}\\n- change_strategy params: {unit_strategy:'excel_row'|'subfolder'|'id_in_filename'|'fallback'}\\nReturn JSON array only.\"\n    }\n  ]\n}",
        "options": {}
      }
    },
    {
      "id": "10",
      "name": "Apply Operations",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        980,
        760
      ],
      "parameters": {
        "functionCode": "const { applyOperations } = require('staffbotics-helpers');\n\nfunction safeParseJsonArray(text) {\n  if (!text || typeof text !== 'string') return [];\n  try {\n    const parsed = JSON.parse(text);\n    return Array.isArray(parsed) ? parsed : [];\n  } catch (e) {}\n  const m = text.match(/\\[[\\s\\S]*\\]/);\n  if (m) {\n    try {\n      const parsed = JSON.parse(m[0]);\n      return Array.isArray(parsed) ? parsed : [];\n    } catch (e) {}\n  }\n  return [];\n}\n\n// Reorg webhook payload (the state the user sends in)\nconst payload = $node['Apply Reorg (Webhook)'].json.body ?? {};\nconst patientCandidates = payload.patientCandidates ?? [];\nconst rawItems = payload.rawItems ?? [];\nconst userInstruction = payload.instruction ?? '';\n\n// LLM operations response content\nconst llmResp = items[0].json;\nconst content = llmResp?.choices?.[0]?.message?.content ?? '';\nconst operations = safeParseJsonArray(content);\n\n// Build lookup for rawItems to repair reassign stubs\nconst rawItemById = {};\nfor (const ri of rawItems) rawItemById[ri.id] = ri;\n\nconst out = applyOperations(patientCandidates, operations, userInstruction);\n\n// Repair stubs produced by applyOperations(reassign)\nfor (const pc of out.patientCandidates || []) {\n  pc.raw_items = (pc.raw_items || []).map(ri => {\n    if (ri && ri.source_ref === 'reassigned' && rawItemById[ri.id]) return rawItemById[ri.id];\n    return ri;\n  });\n}\n\nreturn [{\n  json: {\n    patientCandidates: out.patientCandidates,\n    operationsApplied: out.operationsApplied,\n    userInstruction,\n    rawItems,\n    llm_raw: content\n  }\n}];"
      }
    }
  ],
  "connections": {
    "Receive Batch (Webhook)": {
      "main": [
        [
          {
            "node": "Build RawItems",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build RawItems": {
      "main": [
        [
          {
            "node": "Heuristic Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Heuristic Analysis": {
      "main": [
        [
          {
            "node": "Structure Advisor (LLM)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structure Advisor (LLM)": {
      "main": [
        [
          {
            "node": "Parse LLM Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse LLM Config": {
      "main": [
        [
          {
            "node": "Auto Grouping",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Auto Grouping": {
      "main": [
        [
          {
            "node": "Summarize Proposal",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apply Reorg (Webhook)": {
      "main": [
        [
          {
            "node": "NL → Operations (LLM)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "NL → Operations (LLM)": {
      "main": [
        [
          {
            "node": "Apply Operations",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {},
  "versionId": "staffbotics-patient-grouping-v1",
  "active": true
}